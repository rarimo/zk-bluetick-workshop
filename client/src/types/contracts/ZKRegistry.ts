/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace VerifierHelper {
  export type ProofPointsStruct = {
    a: [BigNumberish, BigNumberish];
    b: [[BigNumberish, BigNumberish], [BigNumberish, BigNumberish]];
    c: [BigNumberish, BigNumberish];
  };

  export type ProofPointsStructOutput = [
    [BigNumber, BigNumber],
    [[BigNumber, BigNumber], [BigNumber, BigNumber]],
    [BigNumber, BigNumber]
  ] & {
    a: [BigNumber, BigNumber];
    b: [[BigNumber, BigNumber], [BigNumber, BigNumber]];
    c: [BigNumber, BigNumber];
  };
}

export declare namespace SparseMerkleTree {
  export type ProofStruct = {
    root: BytesLike;
    siblings: BytesLike[];
    existence: boolean;
    key: BytesLike;
    value: BytesLike;
    auxExistence: boolean;
    auxKey: BytesLike;
    auxValue: BytesLike;
  };

  export type ProofStructOutput = [
    string,
    string[],
    boolean,
    string,
    string,
    boolean,
    string,
    string
  ] & {
    root: string;
    siblings: string[];
    existence: boolean;
    key: string;
    value: string;
    auxExistence: boolean;
    auxKey: string;
    auxValue: string;
  };
}

export interface ZKRegistryInterface extends utils.Interface {
  functions: {
    "COMMITMENT_VERIFIER()": FunctionFragment;
    "ROOT_VALIDITY()": FunctionFragment;
    "UPGRADE_INTERFACE_VERSION()": FunctionFragment;
    "__ZKRegistry_init(address,uint32)": FunctionFragment;
    "commitUserRegistration(bytes32,address,(uint256[2],uint256[2][2],uint256[2]))": FunctionFragment;
    "completeUserRegistration(bytes32,bytes32,bytes32,bytes32,bytes)": FunctionFragment;
    "getMaxHeight()": FunctionFragment;
    "getProof(bytes32)": FunctionFragment;
    "getRoot()": FunctionFragment;
    "getValue(bytes32)": FunctionFragment;
    "implementation()": FunctionFragment;
    "isRootLatest(bytes32)": FunctionFragment;
    "isRootValid(bytes32)": FunctionFragment;
    "owner()": FunctionFragment;
    "proxiableUUID()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "signatureCommitments(bytes32)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "updateZKPassValidator(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
    "userAddresses(bytes32)": FunctionFragment;
    "userHandles(address)": FunctionFragment;
    "zkpassValidator()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "COMMITMENT_VERIFIER"
      | "ROOT_VALIDITY"
      | "UPGRADE_INTERFACE_VERSION"
      | "__ZKRegistry_init"
      | "commitUserRegistration"
      | "completeUserRegistration"
      | "getMaxHeight"
      | "getProof"
      | "getRoot"
      | "getValue"
      | "implementation"
      | "isRootLatest"
      | "isRootValid"
      | "owner"
      | "proxiableUUID"
      | "renounceOwnership"
      | "signatureCommitments"
      | "transferOwnership"
      | "updateZKPassValidator"
      | "upgradeToAndCall"
      | "userAddresses"
      | "userHandles"
      | "zkpassValidator"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "COMMITMENT_VERIFIER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ROOT_VALIDITY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "UPGRADE_INTERFACE_VERSION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "__ZKRegistry_init",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "commitUserRegistration",
    values: [BytesLike, string, VerifierHelper.ProofPointsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "completeUserRegistration",
    values: [BytesLike, BytesLike, BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getMaxHeight",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getProof", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "getRoot", values?: undefined): string;
  encodeFunctionData(functionFragment: "getValue", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "implementation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isRootLatest",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isRootValid",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "signatureCommitments",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateZKPassValidator",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "userAddresses",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "userHandles", values: [string]): string;
  encodeFunctionData(
    functionFragment: "zkpassValidator",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "COMMITMENT_VERIFIER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ROOT_VALIDITY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "UPGRADE_INTERFACE_VERSION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "__ZKRegistry_init",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "commitUserRegistration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "completeUserRegistration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMaxHeight",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getProof", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getRoot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getValue", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "implementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isRootLatest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isRootValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signatureCommitments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateZKPassValidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userAddresses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userHandles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "zkpassValidator",
    data: BytesLike
  ): Result;

  events: {
    "CommitmentRegistered(bytes32)": EventFragment;
    "Initialized(uint64)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "RootUpdated(bytes32)": EventFragment;
    "Upgraded(address)": EventFragment;
    "UserRegistered(address,bytes32)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CommitmentRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RootUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserRegistered"): EventFragment;
}

export interface CommitmentRegisteredEventObject {
  signatureCommitment: string;
}
export type CommitmentRegisteredEvent = TypedEvent<
  [string],
  CommitmentRegisteredEventObject
>;

export type CommitmentRegisteredEventFilter =
  TypedEventFilter<CommitmentRegisteredEvent>;

export interface InitializedEventObject {
  version: BigNumber;
}
export type InitializedEvent = TypedEvent<[BigNumber], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface RootUpdatedEventObject {
  root: string;
}
export type RootUpdatedEvent = TypedEvent<[string], RootUpdatedEventObject>;

export type RootUpdatedEventFilter = TypedEventFilter<RootUpdatedEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface UserRegisteredEventObject {
  user: string;
  handleHash: string;
}
export type UserRegisteredEvent = TypedEvent<
  [string, string],
  UserRegisteredEventObject
>;

export type UserRegisteredEventFilter = TypedEventFilter<UserRegisteredEvent>;

export interface ZKRegistry extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ZKRegistryInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    COMMITMENT_VERIFIER(overrides?: CallOverrides): Promise<[string]>;

    ROOT_VALIDITY(overrides?: CallOverrides): Promise<[BigNumber]>;

    UPGRADE_INTERFACE_VERSION(overrides?: CallOverrides): Promise<[string]>;

    __ZKRegistry_init(
      zkpassValidator_: string,
      maxDepth_: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    commitUserRegistration(
      signatureCommitment_: BytesLike,
      userAddress_: string,
      points_: VerifierHelper.ProofPointsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    completeUserRegistration(
      taskIdHex_: BytesLike,
      schemaIdHex_: BytesLike,
      uHash_: BytesLike,
      publicFieldsHash_: BytesLike,
      signature_: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getMaxHeight(overrides?: CallOverrides): Promise<[BigNumber]>;

    getProof(
      key_: BytesLike,
      overrides?: CallOverrides
    ): Promise<[SparseMerkleTree.ProofStructOutput]>;

    getRoot(overrides?: CallOverrides): Promise<[string]>;

    getValue(key_: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    implementation(overrides?: CallOverrides): Promise<[string]>;

    isRootLatest(
      root_: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isRootValid(
      root_: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    signatureCommitments(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateZKPassValidator(
      zkpassValidator_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    userAddresses(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    userHandles(arg0: string, overrides?: CallOverrides): Promise<[string]>;

    zkpassValidator(overrides?: CallOverrides): Promise<[string]>;
  };

  COMMITMENT_VERIFIER(overrides?: CallOverrides): Promise<string>;

  ROOT_VALIDITY(overrides?: CallOverrides): Promise<BigNumber>;

  UPGRADE_INTERFACE_VERSION(overrides?: CallOverrides): Promise<string>;

  __ZKRegistry_init(
    zkpassValidator_: string,
    maxDepth_: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  commitUserRegistration(
    signatureCommitment_: BytesLike,
    userAddress_: string,
    points_: VerifierHelper.ProofPointsStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  completeUserRegistration(
    taskIdHex_: BytesLike,
    schemaIdHex_: BytesLike,
    uHash_: BytesLike,
    publicFieldsHash_: BytesLike,
    signature_: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getMaxHeight(overrides?: CallOverrides): Promise<BigNumber>;

  getProof(
    key_: BytesLike,
    overrides?: CallOverrides
  ): Promise<SparseMerkleTree.ProofStructOutput>;

  getRoot(overrides?: CallOverrides): Promise<string>;

  getValue(key_: BytesLike, overrides?: CallOverrides): Promise<string>;

  implementation(overrides?: CallOverrides): Promise<string>;

  isRootLatest(root_: BytesLike, overrides?: CallOverrides): Promise<boolean>;

  isRootValid(root_: BytesLike, overrides?: CallOverrides): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  signatureCommitments(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateZKPassValidator(
    zkpassValidator_: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  userAddresses(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  userHandles(arg0: string, overrides?: CallOverrides): Promise<string>;

  zkpassValidator(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    COMMITMENT_VERIFIER(overrides?: CallOverrides): Promise<string>;

    ROOT_VALIDITY(overrides?: CallOverrides): Promise<BigNumber>;

    UPGRADE_INTERFACE_VERSION(overrides?: CallOverrides): Promise<string>;

    __ZKRegistry_init(
      zkpassValidator_: string,
      maxDepth_: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    commitUserRegistration(
      signatureCommitment_: BytesLike,
      userAddress_: string,
      points_: VerifierHelper.ProofPointsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    completeUserRegistration(
      taskIdHex_: BytesLike,
      schemaIdHex_: BytesLike,
      uHash_: BytesLike,
      publicFieldsHash_: BytesLike,
      signature_: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    getMaxHeight(overrides?: CallOverrides): Promise<BigNumber>;

    getProof(
      key_: BytesLike,
      overrides?: CallOverrides
    ): Promise<SparseMerkleTree.ProofStructOutput>;

    getRoot(overrides?: CallOverrides): Promise<string>;

    getValue(key_: BytesLike, overrides?: CallOverrides): Promise<string>;

    implementation(overrides?: CallOverrides): Promise<string>;

    isRootLatest(root_: BytesLike, overrides?: CallOverrides): Promise<boolean>;

    isRootValid(root_: BytesLike, overrides?: CallOverrides): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    signatureCommitments(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    updateZKPassValidator(
      zkpassValidator_: string,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    userAddresses(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    userHandles(arg0: string, overrides?: CallOverrides): Promise<string>;

    zkpassValidator(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "CommitmentRegistered(bytes32)"(
      signatureCommitment?: null
    ): CommitmentRegisteredEventFilter;
    CommitmentRegistered(
      signatureCommitment?: null
    ): CommitmentRegisteredEventFilter;

    "Initialized(uint64)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "RootUpdated(bytes32)"(root?: null): RootUpdatedEventFilter;
    RootUpdated(root?: null): RootUpdatedEventFilter;

    "Upgraded(address)"(implementation?: string | null): UpgradedEventFilter;
    Upgraded(implementation?: string | null): UpgradedEventFilter;

    "UserRegistered(address,bytes32)"(
      user?: null,
      handleHash?: BytesLike | null
    ): UserRegisteredEventFilter;
    UserRegistered(
      user?: null,
      handleHash?: BytesLike | null
    ): UserRegisteredEventFilter;
  };

  estimateGas: {
    COMMITMENT_VERIFIER(overrides?: CallOverrides): Promise<BigNumber>;

    ROOT_VALIDITY(overrides?: CallOverrides): Promise<BigNumber>;

    UPGRADE_INTERFACE_VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    __ZKRegistry_init(
      zkpassValidator_: string,
      maxDepth_: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    commitUserRegistration(
      signatureCommitment_: BytesLike,
      userAddress_: string,
      points_: VerifierHelper.ProofPointsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    completeUserRegistration(
      taskIdHex_: BytesLike,
      schemaIdHex_: BytesLike,
      uHash_: BytesLike,
      publicFieldsHash_: BytesLike,
      signature_: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getMaxHeight(overrides?: CallOverrides): Promise<BigNumber>;

    getProof(key_: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    getRoot(overrides?: CallOverrides): Promise<BigNumber>;

    getValue(key_: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    implementation(overrides?: CallOverrides): Promise<BigNumber>;

    isRootLatest(
      root_: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isRootValid(
      root_: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    signatureCommitments(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateZKPassValidator(
      zkpassValidator_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    userAddresses(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userHandles(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    zkpassValidator(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    COMMITMENT_VERIFIER(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    ROOT_VALIDITY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    UPGRADE_INTERFACE_VERSION(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    __ZKRegistry_init(
      zkpassValidator_: string,
      maxDepth_: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    commitUserRegistration(
      signatureCommitment_: BytesLike,
      userAddress_: string,
      points_: VerifierHelper.ProofPointsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    completeUserRegistration(
      taskIdHex_: BytesLike,
      schemaIdHex_: BytesLike,
      uHash_: BytesLike,
      publicFieldsHash_: BytesLike,
      signature_: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getMaxHeight(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getProof(
      key_: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getValue(
      key_: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    implementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isRootLatest(
      root_: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isRootValid(
      root_: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    signatureCommitments(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateZKPassValidator(
      zkpassValidator_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    userAddresses(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userHandles(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    zkpassValidator(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
